// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: trade.proto

package trade

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Trade_CreateLimitOrder_FullMethodName   = "/trade.Trade/CreateLimitOrder"
	Trade_CancelOrder_FullMethodName        = "/trade.Trade/CancelOrder"
	Trade_CreateMarketOrder_FullMethodName  = "/trade.Trade/CreateMarketOrder"
	Trade_CreatePool_FullMethodName         = "/trade.Trade/CreatePool"
	Trade_QueryCurrentOrders_FullMethodName = "/trade.Trade/QueryCurrentOrders"
	Trade_QueryTradeHistory_FullMethodName  = "/trade.Trade/QueryTradeHistory"
	Trade_QueryOrderHistory_FullMethodName  = "/trade.Trade/QueryOrderHistory"
	Trade_ProcTokenPrice_FullMethodName     = "/trade.Trade/ProcTokenPrice"
	Trade_ProcTokenCap_FullMethodName       = "/trade.Trade/ProcTokenCap"
	Trade_CreateTrailingStop_FullMethodName = "/trade.Trade/CreateTrailingStop"
	Trade_ProcTrailingStop_FullMethodName   = "/trade.Trade/ProcTrailingStop"
	Trade_QueryHoldingToken_FullMethodName  = "/trade.Trade/QueryHoldingToken"
	Trade_GetGasInfo_FullMethodName         = "/trade.Trade/GetGasInfo"
	Trade_AddLiquidityV1_FullMethodName     = "/trade.Trade/AddLiquidityV1"
	Trade_TestRpc_FullMethodName            = "/trade.Trade/TestRpc"
	Trade_Transfer_FullMethodName           = "/trade.Trade/Transfer"
	Trade_QueryTransfer_FullMethodName      = "/trade.Trade/QueryTransfer"
)

// TradeClient is the client API for Trade service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TradeClient interface {
	CreateLimitOrder(ctx context.Context, in *CreateLimitOrderRequest, opts ...grpc.CallOption) (*CreateLimitOrderResponse, error)
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error)
	CreateMarketOrder(ctx context.Context, in *CreateMarketOrderRequest, opts ...grpc.CallOption) (*CreateMarketOrderResponse, error)
	CreatePool(ctx context.Context, in *CreatePoolRequest, opts ...grpc.CallOption) (*CreatePoolResponse, error)
	QueryCurrentOrders(ctx context.Context, in *QueryCurrentOrdersRequest, opts ...grpc.CallOption) (*QueryCurrentOrdersResponse, error)
	QueryTradeHistory(ctx context.Context, in *QueryTradeHistoryRequest, opts ...grpc.CallOption) (*QueryTradeHistoryResponse, error)
	QueryOrderHistory(ctx context.Context, in *QueryOrderHistoryRequest, opts ...grpc.CallOption) (*QueryOrderHistoryResponse, error)
	ProcTokenPrice(ctx context.Context, in *ProcTokenPriceRequest, opts ...grpc.CallOption) (*ProcTokenPriceResponse, error)
	ProcTokenCap(ctx context.Context, in *ProcTokenCapRequest, opts ...grpc.CallOption) (*ProcTokenCapResponse, error)
	CreateTrailingStop(ctx context.Context, in *CreateTrailingStopRequest, opts ...grpc.CallOption) (*CreateTrailingStopResponse, error)
	ProcTrailingStop(ctx context.Context, in *ProcTokenPriceRequest, opts ...grpc.CallOption) (*ProcTokenPriceResponse, error)
	QueryHoldingToken(ctx context.Context, in *QueryHoldTokenRequest, opts ...grpc.CallOption) (*QueryHoldTokenResponse, error)
	GetGasInfo(ctx context.Context, in *GetGasInfoRequest, opts ...grpc.CallOption) (*GetGasInfoResponse, error)
	AddLiquidityV1(ctx context.Context, in *AddLiquidityRequest, opts ...grpc.CallOption) (*AddLiquidityResponse, error)
	TestRpc(ctx context.Context, in *TestRpcRequest, opts ...grpc.CallOption) (*TestRpcResponse, error)
	// internal
	Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error)
	QueryTransfer(ctx context.Context, in *QueryTransferRequest, opts ...grpc.CallOption) (*QueryTransferResponse, error)
}

type tradeClient struct {
	cc grpc.ClientConnInterface
}

func NewTradeClient(cc grpc.ClientConnInterface) TradeClient {
	return &tradeClient{cc}
}

func (c *tradeClient) CreateLimitOrder(ctx context.Context, in *CreateLimitOrderRequest, opts ...grpc.CallOption) (*CreateLimitOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLimitOrderResponse)
	err := c.cc.Invoke(ctx, Trade_CreateLimitOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelOrderResponse)
	err := c.cc.Invoke(ctx, Trade_CancelOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) CreateMarketOrder(ctx context.Context, in *CreateMarketOrderRequest, opts ...grpc.CallOption) (*CreateMarketOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateMarketOrderResponse)
	err := c.cc.Invoke(ctx, Trade_CreateMarketOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) CreatePool(ctx context.Context, in *CreatePoolRequest, opts ...grpc.CallOption) (*CreatePoolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePoolResponse)
	err := c.cc.Invoke(ctx, Trade_CreatePool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) QueryCurrentOrders(ctx context.Context, in *QueryCurrentOrdersRequest, opts ...grpc.CallOption) (*QueryCurrentOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryCurrentOrdersResponse)
	err := c.cc.Invoke(ctx, Trade_QueryCurrentOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) QueryTradeHistory(ctx context.Context, in *QueryTradeHistoryRequest, opts ...grpc.CallOption) (*QueryTradeHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTradeHistoryResponse)
	err := c.cc.Invoke(ctx, Trade_QueryTradeHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) QueryOrderHistory(ctx context.Context, in *QueryOrderHistoryRequest, opts ...grpc.CallOption) (*QueryOrderHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryOrderHistoryResponse)
	err := c.cc.Invoke(ctx, Trade_QueryOrderHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) ProcTokenPrice(ctx context.Context, in *ProcTokenPriceRequest, opts ...grpc.CallOption) (*ProcTokenPriceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcTokenPriceResponse)
	err := c.cc.Invoke(ctx, Trade_ProcTokenPrice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) ProcTokenCap(ctx context.Context, in *ProcTokenCapRequest, opts ...grpc.CallOption) (*ProcTokenCapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcTokenCapResponse)
	err := c.cc.Invoke(ctx, Trade_ProcTokenCap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) CreateTrailingStop(ctx context.Context, in *CreateTrailingStopRequest, opts ...grpc.CallOption) (*CreateTrailingStopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTrailingStopResponse)
	err := c.cc.Invoke(ctx, Trade_CreateTrailingStop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) ProcTrailingStop(ctx context.Context, in *ProcTokenPriceRequest, opts ...grpc.CallOption) (*ProcTokenPriceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcTokenPriceResponse)
	err := c.cc.Invoke(ctx, Trade_ProcTrailingStop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) QueryHoldingToken(ctx context.Context, in *QueryHoldTokenRequest, opts ...grpc.CallOption) (*QueryHoldTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryHoldTokenResponse)
	err := c.cc.Invoke(ctx, Trade_QueryHoldingToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) GetGasInfo(ctx context.Context, in *GetGasInfoRequest, opts ...grpc.CallOption) (*GetGasInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGasInfoResponse)
	err := c.cc.Invoke(ctx, Trade_GetGasInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) AddLiquidityV1(ctx context.Context, in *AddLiquidityRequest, opts ...grpc.CallOption) (*AddLiquidityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddLiquidityResponse)
	err := c.cc.Invoke(ctx, Trade_AddLiquidityV1_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) TestRpc(ctx context.Context, in *TestRpcRequest, opts ...grpc.CallOption) (*TestRpcResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestRpcResponse)
	err := c.cc.Invoke(ctx, Trade_TestRpc_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) Transfer(ctx context.Context, in *TransferRequest, opts ...grpc.CallOption) (*TransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferResponse)
	err := c.cc.Invoke(ctx, Trade_Transfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tradeClient) QueryTransfer(ctx context.Context, in *QueryTransferRequest, opts ...grpc.CallOption) (*QueryTransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryTransferResponse)
	err := c.cc.Invoke(ctx, Trade_QueryTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TradeServer is the server API for Trade service.
// All implementations must embed UnimplementedTradeServer
// for forward compatibility.
type TradeServer interface {
	CreateLimitOrder(context.Context, *CreateLimitOrderRequest) (*CreateLimitOrderResponse, error)
	CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error)
	CreateMarketOrder(context.Context, *CreateMarketOrderRequest) (*CreateMarketOrderResponse, error)
	CreatePool(context.Context, *CreatePoolRequest) (*CreatePoolResponse, error)
	QueryCurrentOrders(context.Context, *QueryCurrentOrdersRequest) (*QueryCurrentOrdersResponse, error)
	QueryTradeHistory(context.Context, *QueryTradeHistoryRequest) (*QueryTradeHistoryResponse, error)
	QueryOrderHistory(context.Context, *QueryOrderHistoryRequest) (*QueryOrderHistoryResponse, error)
	ProcTokenPrice(context.Context, *ProcTokenPriceRequest) (*ProcTokenPriceResponse, error)
	ProcTokenCap(context.Context, *ProcTokenCapRequest) (*ProcTokenCapResponse, error)
	CreateTrailingStop(context.Context, *CreateTrailingStopRequest) (*CreateTrailingStopResponse, error)
	ProcTrailingStop(context.Context, *ProcTokenPriceRequest) (*ProcTokenPriceResponse, error)
	QueryHoldingToken(context.Context, *QueryHoldTokenRequest) (*QueryHoldTokenResponse, error)
	GetGasInfo(context.Context, *GetGasInfoRequest) (*GetGasInfoResponse, error)
	AddLiquidityV1(context.Context, *AddLiquidityRequest) (*AddLiquidityResponse, error)
	TestRpc(context.Context, *TestRpcRequest) (*TestRpcResponse, error)
	// internal
	Transfer(context.Context, *TransferRequest) (*TransferResponse, error)
	QueryTransfer(context.Context, *QueryTransferRequest) (*QueryTransferResponse, error)
	mustEmbedUnimplementedTradeServer()
}

// UnimplementedTradeServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTradeServer struct{}

func (UnimplementedTradeServer) CreateLimitOrder(context.Context, *CreateLimitOrderRequest) (*CreateLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLimitOrder not implemented")
}
func (UnimplementedTradeServer) CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (UnimplementedTradeServer) CreateMarketOrder(context.Context, *CreateMarketOrderRequest) (*CreateMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMarketOrder not implemented")
}
func (UnimplementedTradeServer) CreatePool(context.Context, *CreatePoolRequest) (*CreatePoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePool not implemented")
}
func (UnimplementedTradeServer) QueryCurrentOrders(context.Context, *QueryCurrentOrdersRequest) (*QueryCurrentOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryCurrentOrders not implemented")
}
func (UnimplementedTradeServer) QueryTradeHistory(context.Context, *QueryTradeHistoryRequest) (*QueryTradeHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTradeHistory not implemented")
}
func (UnimplementedTradeServer) QueryOrderHistory(context.Context, *QueryOrderHistoryRequest) (*QueryOrderHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryOrderHistory not implemented")
}
func (UnimplementedTradeServer) ProcTokenPrice(context.Context, *ProcTokenPriceRequest) (*ProcTokenPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcTokenPrice not implemented")
}
func (UnimplementedTradeServer) ProcTokenCap(context.Context, *ProcTokenCapRequest) (*ProcTokenCapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcTokenCap not implemented")
}
func (UnimplementedTradeServer) CreateTrailingStop(context.Context, *CreateTrailingStopRequest) (*CreateTrailingStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrailingStop not implemented")
}
func (UnimplementedTradeServer) ProcTrailingStop(context.Context, *ProcTokenPriceRequest) (*ProcTokenPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcTrailingStop not implemented")
}
func (UnimplementedTradeServer) QueryHoldingToken(context.Context, *QueryHoldTokenRequest) (*QueryHoldTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryHoldingToken not implemented")
}
func (UnimplementedTradeServer) GetGasInfo(context.Context, *GetGasInfoRequest) (*GetGasInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGasInfo not implemented")
}
func (UnimplementedTradeServer) AddLiquidityV1(context.Context, *AddLiquidityRequest) (*AddLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLiquidityV1 not implemented")
}
func (UnimplementedTradeServer) TestRpc(context.Context, *TestRpcRequest) (*TestRpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestRpc not implemented")
}
func (UnimplementedTradeServer) Transfer(context.Context, *TransferRequest) (*TransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedTradeServer) QueryTransfer(context.Context, *QueryTransferRequest) (*QueryTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTransfer not implemented")
}
func (UnimplementedTradeServer) mustEmbedUnimplementedTradeServer() {}
func (UnimplementedTradeServer) testEmbeddedByValue()               {}

// UnsafeTradeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TradeServer will
// result in compilation errors.
type UnsafeTradeServer interface {
	mustEmbedUnimplementedTradeServer()
}

func RegisterTradeServer(s grpc.ServiceRegistrar, srv TradeServer) {
	// If the following call pancis, it indicates UnimplementedTradeServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Trade_ServiceDesc, srv)
}

func _Trade_CreateLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLimitOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).CreateLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_CreateLimitOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).CreateLimitOrder(ctx, req.(*CreateLimitOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_CancelOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_CreateMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMarketOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).CreateMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_CreateMarketOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).CreateMarketOrder(ctx, req.(*CreateMarketOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_CreatePool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).CreatePool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_CreatePool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).CreatePool(ctx, req.(*CreatePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_QueryCurrentOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryCurrentOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).QueryCurrentOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_QueryCurrentOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).QueryCurrentOrders(ctx, req.(*QueryCurrentOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_QueryTradeHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTradeHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).QueryTradeHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_QueryTradeHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).QueryTradeHistory(ctx, req.(*QueryTradeHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_QueryOrderHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryOrderHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).QueryOrderHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_QueryOrderHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).QueryOrderHistory(ctx, req.(*QueryOrderHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_ProcTokenPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcTokenPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).ProcTokenPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_ProcTokenPrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).ProcTokenPrice(ctx, req.(*ProcTokenPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_ProcTokenCap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcTokenCapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).ProcTokenCap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_ProcTokenCap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).ProcTokenCap(ctx, req.(*ProcTokenCapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_CreateTrailingStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTrailingStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).CreateTrailingStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_CreateTrailingStop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).CreateTrailingStop(ctx, req.(*CreateTrailingStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_ProcTrailingStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcTokenPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).ProcTrailingStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_ProcTrailingStop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).ProcTrailingStop(ctx, req.(*ProcTokenPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_QueryHoldingToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHoldTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).QueryHoldingToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_QueryHoldingToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).QueryHoldingToken(ctx, req.(*QueryHoldTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_GetGasInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGasInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).GetGasInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_GetGasInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).GetGasInfo(ctx, req.(*GetGasInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_AddLiquidityV1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).AddLiquidityV1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_AddLiquidityV1_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).AddLiquidityV1(ctx, req.(*AddLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_TestRpc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestRpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).TestRpc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_TestRpc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).TestRpc(ctx, req.(*TestRpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_Transfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).Transfer(ctx, req.(*TransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Trade_QueryTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TradeServer).QueryTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Trade_QueryTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TradeServer).QueryTransfer(ctx, req.(*QueryTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Trade_ServiceDesc is the grpc.ServiceDesc for Trade service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Trade_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "trade.Trade",
	HandlerType: (*TradeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLimitOrder",
			Handler:    _Trade_CreateLimitOrder_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Trade_CancelOrder_Handler,
		},
		{
			MethodName: "CreateMarketOrder",
			Handler:    _Trade_CreateMarketOrder_Handler,
		},
		{
			MethodName: "CreatePool",
			Handler:    _Trade_CreatePool_Handler,
		},
		{
			MethodName: "QueryCurrentOrders",
			Handler:    _Trade_QueryCurrentOrders_Handler,
		},
		{
			MethodName: "QueryTradeHistory",
			Handler:    _Trade_QueryTradeHistory_Handler,
		},
		{
			MethodName: "QueryOrderHistory",
			Handler:    _Trade_QueryOrderHistory_Handler,
		},
		{
			MethodName: "ProcTokenPrice",
			Handler:    _Trade_ProcTokenPrice_Handler,
		},
		{
			MethodName: "ProcTokenCap",
			Handler:    _Trade_ProcTokenCap_Handler,
		},
		{
			MethodName: "CreateTrailingStop",
			Handler:    _Trade_CreateTrailingStop_Handler,
		},
		{
			MethodName: "ProcTrailingStop",
			Handler:    _Trade_ProcTrailingStop_Handler,
		},
		{
			MethodName: "QueryHoldingToken",
			Handler:    _Trade_QueryHoldingToken_Handler,
		},
		{
			MethodName: "GetGasInfo",
			Handler:    _Trade_GetGasInfo_Handler,
		},
		{
			MethodName: "AddLiquidityV1",
			Handler:    _Trade_AddLiquidityV1_Handler,
		},
		{
			MethodName: "TestRpc",
			Handler:    _Trade_TestRpc_Handler,
		},
		{
			MethodName: "Transfer",
			Handler:    _Trade_Transfer_Handler,
		},
		{
			MethodName: "QueryTransfer",
			Handler:    _Trade_QueryTransfer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trade.proto",
}
