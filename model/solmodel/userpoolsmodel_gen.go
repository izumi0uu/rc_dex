// Code generated by goctl. DO NOT EDIT!

package solmodel

import (
	"context"
	"database/sql"
	"strings"
	"time"

	"github.com/klen-ygs/gorm-zero/gormc"
	. "github.com/klen-ygs/gorm-zero/gormc/sql"
	"gorm.io/gorm"
)

// avoid unused err
var _ = time.Second

type (
	userPoolsModel interface {
		Insert(ctx context.Context, data *UserPools) error

		FindOne(ctx context.Context, id int64) (*UserPools, error)
		FindOneByUserWalletAddressPoolState(ctx context.Context, userWalletAddress string, poolState string) (*UserPools, error)
		Update(ctx context.Context, data *UserPools) error

		Delete(ctx context.Context, id int64) error
	}

	defaultUserPoolsModel struct {
		conn  *gorm.DB
		table string
	}

	UserPools struct {
		Id                int64        `gorm:"column:id"`
		UserWalletAddress string       `gorm:"column:user_wallet_address"` // User wallet address
		ChainId           int64        `gorm:"column:chain_id"`            // Chain ID
		PoolState         string       `gorm:"column:pool_state"`          // Pool state account
		InputVaultMint    string       `gorm:"column:input_vault_mint"`    // Token A mint address
		OutputVaultMint   string       `gorm:"column:output_vault_mint"`   // Token B mint address
		Token0Symbol      string       `gorm:"column:token0_symbol"`       // Token A symbol
		Token1Symbol      string       `gorm:"column:token1_symbol"`       // Token B symbol
		Token0Decimals    int64        `gorm:"column:token0_decimals"`     // Token A decimals
		Token1Decimals    int64        `gorm:"column:token1_decimals"`     // Token B decimals
		Token0Liquidity   float64      `gorm:"column:token0_liquidity"`    // Token A liquidity amount
		Token1Liquidity   float64      `gorm:"column:token1_liquidity"`    // Token B liquidity amount
		InitialPrice      float64      `gorm:"column:initial_price"`       // Initial price
		TradeFeeRate      int64        `gorm:"column:trade_fee_rate"`      // Fee rate in basis points
		TxHash            string       `gorm:"column:tx_hash"`             // Creation transaction hash
		PoolVersion       string       `gorm:"column:pool_version"`        // Pool version (v1, v2)
		PoolType          string       `gorm:"column:pool_type"`           // Pool type (clmm, cpmm)
		AmmConfig         string       `gorm:"column:amm_config"`          // AMM config address
		CreatedAt         time.Time    `gorm:"column:created_at"`          // Creation timestamp
		UpdatedAt         time.Time    `gorm:"column:updated_at"`          // Update timestamp
		DeletedAt         sql.NullTime `gorm:"column:deleted_at;index"`    // Soft delete timestamp
	}
)

var QUserPools UserPools

func init() {
	InitField(&QUserPools)
}

func (UserPools) TableName() string {
	return strings.Trim("`user_pools`", "`")
}

func newUserPoolsModel(conn *gorm.DB) *defaultUserPoolsModel {
	return &defaultUserPoolsModel{
		conn:  conn,
		table: strings.Trim("`user_pools`", "`"),
	}
}

func (m *defaultUserPoolsModel) Insert(ctx context.Context, data *UserPools) error {
	db := m.conn
	err := db.WithContext(ctx).Save(&data).Error
	return err
}

func (m *defaultUserPoolsModel) FindOne(ctx context.Context, id int64) (*UserPools, error) {
	var resp UserPools
	err := m.conn.WithContext(ctx).Model(&UserPools{}).Where("`id` = @id", sql.Named("id", id)).Take(&resp).Error
	if err == gormc.ErrNotFound {
		return nil, err
	}
	return &resp, err

}

func (m *defaultUserPoolsModel) FindOneByUserWalletAddressPoolState(ctx context.Context, userWalletAddress string, poolState string) (*UserPools, error) {
	var resp UserPools
	err := m.conn.WithContext(ctx).Model(&UserPools{}).Where("`user_wallet_address` = ? and `pool_state` = ?", userWalletAddress, poolState).Take(&resp).Error
	if err == gormc.ErrNotFound {
		return nil, err
	}
	return &resp, err
}

func (m *defaultUserPoolsModel) Update(ctx context.Context, data *UserPools) error {
	db := m.conn
	err := db.WithContext(ctx).Save(data).Error
	return err
}

func (m *defaultUserPoolsModel) Delete(ctx context.Context, id int64) error {
	db := m.conn
	err := db.WithContext(ctx).Where("`id` = @id", sql.Named("id", id)).Delete(&UserPools{}).Error

	return err
}
